---
layout: post
title: "后台服务高并发编程-抢红包"
date:   2020-1-28
tags: [后台开发]
comments: true
author: lemonchann
---

今年春节响应国家号召在家宅着抵抗疫情，发了很多也抢了很多微信红包，今年拜年也改用微信红包，如今微信抢红包已经是非常平常的事情。

抢红包这一简单的动作，每一次都是对红包服务后台的一次请求，在春节期间海量的服务请求下，其实是一个很典型的高并发编程模型。后台开发程序员都有一个共识：**实现一个功能很容易，难的是大量请求下提高服务性能**。

在程序员眼里，大家抢的不是红包，是红包后台服务的**锁** ！这里的**锁**不是我们日常生活中的锁，后台服务编程中锁的概念：

> **实现多个进程或线程互斥的访问共享资源的一种机制**

### 今天和大家聊聊后台服务编程中的锁。

## 业务模型

为便于说明，我们简化模型，约定抢红包服务是多线程服务，抢红包操作包含以下3个步骤：

1. 查询数据库内红包余额
2. 扣除抢到的红包金额
3. 更新红包余额到数据库

假设发了100块钱红包，1000个人1秒内同时来抢（高并发），如果不加锁是这样的情况：

- 第一个人查余额得到100元，他在此基础上扣除抢到的假设2元，准备步骤3更新到数据库。
- 在第一个人更新进去之前，此时剩下的人查到的余额也是100，他们各自扣除抢到的金额，准备按步骤3更新。
- 导致最后的红包余额只记录了最后一次更新的数据。
- 很明显，这就可能出现1000个人都抢到红包，但是红包余额还没分完的情况，这就乱了。

怎么解决这个问题呢? 就用到我们上面说的**加锁**来解决，把抢红包这三个步骤做成互斥操作，**在我抢了没更新数据之前你别来查余额，查到也不准确**。也可以类比数据库的**事务**来理解。



## 有哪些锁

实现锁的方式有很多，这里列举几种常见的分类

### 悲观锁

>  顾名思义就是悲观的做最坏打算的锁机制，占有锁期间独占资源。

它假设你每次去抢红包必然有其他人也在跟你同时在抢，所以你这条线程在抢的时候要独占资源，其他线程需要阻塞挂起等待你抢完才能进来，挂起的线程就干不了其他事了，何其浪费！

而一旦你抢完红包释放了锁，其他在等待中的线程又要抢占资源、抢到了又要恢复线程上下文。

CPU不断的切换线程上下文非常浪费服务器资源，严重的会导致不能及时处理后续抢红包请求，需要想办法提高效率，于是有了**乐观锁**

### 乐观锁

> 乐观锁是对悲观锁的改进，乐观锁不阻塞线程。

一种实现乐观锁的方法是，数据库内红包余额增加版本号。初始版本号是0，每次抢完红包版本号加一后再去更新余额，只有更新的版本号大于数据库内的版本号才认为是合法的，予以更新；否则不予更新，线程不阻塞可以稍后重试，避免频繁切换线程上下文。

- 第一个人抢到版本号是0的红包，第二个人也抢到版本号是0的红包
- 第一个人更新红包余额并设置版本号为1
- 第二个人更新红包余额设置版本号为1的时候发现余额版本号已经为1，更新失败
- 第二个人更新失败后，**线程不阻塞，继续处理其他抢红包抢请求**，按**一定策略重试**（超时重试、有限次数重试）第二个人的更新操作
- 其他请求以此类推

可以看到，乐观锁在加锁失败的时候不挂起线程等待，避免了线程上下文频繁的切换，提高红包服务处理性能。

### 分布式锁

上面两种锁的形式都是基于对数据库的更新来做的，在大请求高并发的时候，频繁的存取数据库，尤其是乐观锁重试会对数据库产生很大的冲击，在实际生产环境要尽量减少对数据库的访问。

Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。也可以用redis实现**分布式锁**，只在第一次获取红包余额和抢完更新红包状态，与数据库交互两次，抢锁和更新操作都在内存中进行，这可比数据库操作快了几个数量级，显著改善服务并发性能。

redis分布式锁：

> 利用Redis的SET操作在内存中保存key-value键值对，加锁就是获取这个键值对的值，解锁就是删除这个键值对。

关于这种分布式锁的实现，在我的另一篇文章说明，[文章链接](1) 

